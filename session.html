<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Karting Session Viewer</title>
  <script src="https://www.youtube.com/iframe_api"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
      color: #e0e0e0;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      background: linear-gradient(135deg, #d32f2f 0%, #f44336 100%);
      padding: 30px;
      border-radius: 12px;
      margin-bottom: 30px;
      box-shadow: 0 8px 32px rgba(211, 47, 47, 0.3);
    }

    .driver-name {
      font-size: 2.5em;
      font-weight: bold;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 20px;
      margin-bottom: 30px;
    }

    @media (max-width: 1200px) {
      .stats-grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    @media (max-width: 768px) {
      .stats-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 600px) {
      .driver-name {
        font-size: 2em;
      }

      .header-content {
        flex-direction: column;
        align-items: flex-start;
      }

      .home-button {
        display: block;
        width: 100%;
        text-align: center;
        margin-top: 20px;
      }

      .comparison-input {
        flex-direction: column;
        gap: 10px;
      }

      .comparison-input input,
      .comparison-input button {
        width: 100%;
      }

      .autocomplete-list {
        left: 0;
        right: 0;
      }
    }

    .stat-card {
      background: #2d2d2d;
      padding: 20px;
      border-radius: 12px;
      border-left: 4px solid #f44336;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }

    .stat-label {
      color: #999;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }

    .stat-value {
      font-size: 1.8em;
      font-weight: bold;
      color: #fff;
    }

    .stat-value.small {
      font-size: 1.4em;
    }

    .fastest-time {
      color: #ffd700;
      font-size: 2.2em;
    }

    .consistency-excellent {
      color: #4caf50;
    }

    .consistency-good {
      color: #8bc34a;
    }

    .consistency-fair {
      color: #ffc107;
    }

    .consistency-poor {
      color: #ff9800;
    }

    .chart-container {
      background: #2d2d2d;
      padding: 30px;
      border-radius: 12px;
      margin-bottom: 30px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
      position: relative;
    }

    .chart-title {
      font-size: 1.5em;
      margin-bottom: 20px;
      color: #fff;
    }

    .line-chart {
      position: relative;
      height: 300px;
      margin-bottom: 10px;
    }

    .chart-canvas {
      width: 100%;
      height: 100%;
    }

    .home-button {
      display: inline-block;
      padding: 10px 20px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      text-decoration: none;
      border-radius: 8px;
      font-weight: bold;
      transition: all 0.3s;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .home-button:hover {
      background: rgba(255, 255, 255, 0.3);
      border-color: rgba(255, 255, 255, 0.5);
      transform: translateY(-2px);
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 20px;
    }

    .header-info {
      flex: 1;
    }

    .socials {
      background: #2d2d2d;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
      text-align: center;
    }

    .socials a {
      display: inline-block;
      margin: 0 15px;
      color: #f44336;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s;
    }

    .socials a:hover {
      color: #ff5252;
      transform: translateY(-2px);
    }

    .track-link {
      color: #f44336;
      text-decoration: none;
      font-weight: 600;
    }

    .track-link:hover {
      color: #ff5252;
    }

    .comparison-container {
      margin-top: 30px;
      padding: 20px;
      background: #2d2d2d;
      border-radius: 12px;
    }

    .comparison-input {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      position: relative;
    }

    .comparison-input input {
      flex: 1;
      padding: 10px;
      background: #1e1e1e;
      border: 2px solid #3d3d3d;
      color: #e0e0e0;
      border-radius: 8px;
      font-size: 1em;
    }

    .autocomplete-list {
      position: absolute;
      top: 100%;
      left: 0;
      right: 170px;
      max-height: 200px;
      overflow-y: auto;
      background: #1e1e1e;
      border: 2px solid #f44336;
      border-top: none;
      border-radius: 0 0 8px 8px;
      z-index: 10;
    }

    .autocomplete-item {
      padding: 10px;
      cursor: pointer;
      border-bottom: 1px solid #3d3d3d;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .autocomplete-item:hover,
    .autocomplete-item.selected {
      background: #f44336;
      color: white;
    }

    .comparison-input button {
      padding: 10px 20px;
      background: #f44336;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s;
    }

    .comparison-input button:hover {
      background: #d32f2f;
    }

    .comparison-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
    }

    .comparison-card {
      background: #1e1e1e;
      padding: 20px;
      border-top: 4px solid #f44336;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .comparison-card h3 {
      margin-bottom: 10px;
      color: #fff;
      font-size: 1.2em;
    }

    .comparison-card p {
      margin: 5px 0;
      font-size: 0.9em;
    }

    .legend {
      display: flex;
      gap: 20px;
      margin-top: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }

    .error-message {
      color: #f44336;
      padding: 10px;
      background: rgba(244, 67, 54, 0.1);
      border-radius: 8px;
      margin-top: 10px;
    }

    .tooltip {
      position: absolute;
      background: rgba(30, 30, 30, 0.95);
      border: 2px solid #f44336;
      border-radius: 8px;
      padding: 12px 16px;
      color: #e0e0e0;
      font-size: 14px;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      max-width: 250px;
      transition: opacity 0.2s ease;
      opacity: 0;
    }

    .tooltip-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      border-bottom: 1px solid #444;
      padding-bottom: 4px;
    }

    .tooltip-driver {
      font-weight: bold;
      color: #4caf50;
    }

    .tooltip-lap {
      color: #f44336;
      font-weight: bold;
    }

    .tooltip-time {
      font-size: 18px;
      font-weight: bold;
      margin: 8px 0;
      color: #fff;
    }

    .tooltip-best {
      color: #ffd700;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .tooltip-delta {
      font-size: 12px;
      color: #999;
    }

    .tooltip-footer {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid #444;
      font-size: 12px;
      color: #aaa;
    }

    .tooltip-visible {
      opacity: 1;
    }

    .tooltip-arrow {
      position: absolute;
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-top: 8px solid #f44336;
      bottom: -8px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1001;
    }

    .point-hover {
      cursor: pointer;
    }

    .video-responsive {
      position: relative;
      padding-bottom: 56.25%;
      height: 0;
      overflow: hidden;
      max-width: 100%;
      background-color: #1e1e1e;
    }

    #youtube-player-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: 0;
    }

    .video-responsive iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border: 0;
    }

    /* Slider Styling */
    #lap-selector-slider {
      -webkit-appearance: none;
      height: 8px;
      background: #3d3d3d;
      border-radius: 4px;
      outline: none;
      cursor: pointer;
    }

    #lap-selector-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #f44336;
      cursor: pointer;
      transition: background .15s ease-in-out;
    }

    #lap-selector-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border: 0;
      border-radius: 50%;
      background: #f44336;
      cursor: pointer;
      transition: background .15s ease-in-out;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="header-content">
        <div class="header-info">
          <div class="driver-name" id="driver"></div>
          <div id="session-date"></div>
        </div>
        <a href="index.html" class="home-button">üè† Home</a>
      </div>
    </div>

    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">Fastest Lap</div>
        <div class="stat-value fastest-time" id="fastest"></div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Average Lap</div>
        <div class="stat-value small" id="average"></div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Consistency</div>
        <div class="stat-value small" id="consistency"></div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Track</div>
        <div class="stat-value" style="font-size: 1.3em;">
          <a class="track-link" id="track-link" target="_blank"></a>
        </div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Kart</div>
        <div class="stat-value" id="kart"></div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Total Laps</div>
        <div class="stat-value" id="total-laps"></div>
      </div>
    </div>

    <div id="video-display-container" class="chart-container" style="display:none;">
    </div>

    <div class="chart-container">
      <div class="chart-title">üìà Lap Time Progression</div>

      <div
        style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px;">
        <span id="current-lap-display"
          style="font-weight: bold; color: #ffd700; font-size: 1.1em; min-width: 130px;">Current Lap: 1</span>
        <input type="range" id="lap-selector-slider" min="1" max="1" value="1" step="1"
          style="flex-grow: 1; margin: 0 20px;">
        <button onclick="seekToLap(parseInt(document.getElementById('lap-selector-slider').value) + 1)"
          style="padding: 8px 15px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">Next
          Lap</button>
      </div>
      <div class="line-chart">
        <canvas id="lap-chart" class="chart-canvas"></canvas>
      </div>
      <div id="chart-legend" class="legend"></div>
    </div>

    <div class="comparison-container">
      <div class="chart-title">üîÑ Compare Sessions</div>
      <div class="comparison-input">
        <input type="text" id="compare-id-input"
          placeholder="Search for session ID or Driver to compare (e.g., uuid1, uuid2)">
        <div id="autocomplete-results" class="autocomplete-list" style="display:none;"></div>
        <button onclick="compareSession()">Compare</button>
        <button onclick="clearComparison()" style="background: #666;">Clear</button>
      </div>
      <div id="comparison-results" class="comparison-grid"></div>
    </div>

    <div class="socials">
      <strong>Follow:</strong>
      <a href="https://www.instagram.com/YourKartingBrand/" target="_blank">Instagram</a>
      <a href="https://www.facebook.com/YourKartingBrand/" target="_blank">Facebook</a>
      <a href="https://www.yourkartingwebsite.com/" target="_blank">Website</a>
    </div>
  </div>

  <div id="chart-tooltip" class="tooltip"></div>

  <script>
    let currentSessionData = null;
    let comparisonSessions = [];
    let chartPoints = [];
    let currentDataset = [];
    let comparisonDatasets = [];
    let activePoint = null;
    let allSessionsList = [];

    // --- VIDEO SYNC GLOBAL VARIABLES ---
    let player; // YouTube Player object
    let pendingVideoConfig = null;

    // NEW: Variable to hold lap start objects {lapNumber, videoTime}
    let lapStartTimes = [];

    // NEW: Variable to track current lap state for the chart
    let currentLapMarker = { lapNumber: 1 };

    // NEW: Interval variable
    let updateChartInterval = null;
    // --- END VIDEO SYNC GLOBAL VARIABLES ---

    const params = new URLSearchParams(window.location.search);
    const sessionId = params.get("id") || "example-session";
    const compareId = params.get("compare_id");
    const compareInput = document.getElementById('compare-id-input');
    if (compareId) {
      compareInput.value = compareId;
    }

    const comparisonColors = [
      { line: '#4caf50', point: '#8bc34a' },
      { line: '#2196f3', point: '#64b5f6' },
      { line: '#ff9800', point: '#ffb74d' },
      { line: '#9c27b0', point: '#ba68c8' },
      { line: '#00bcd4', point: '#4dd0e1' },
      { line: '#ffeb3b', point: '#fff176' },
      { line: '#795548', point: '#a1887f' },
      { line: '#e91e63', point: '#f06292' }
    ];

    // --- Data Loading ---
    fetch('sessions/sessions-list.json')
      .then(r => r.json())
      .then(data => {
        allSessionsList = data.sessions || [];
        setupAutocomplete();
      })
      .catch(err => {
        console.warn("Could not load sessions-list.json for autocomplete.");
      });

    fetch(`sessions/${sessionId}.json`)
      .then(r => {
        if (!r.ok) throw new Error('Main session not found');
        return r.json();
      })
      .then(data => {
        currentSessionData = data;
        renderSession(data);
        compareSession();
      })
      .catch(err => {
        document.body.innerHTML = '<div style="text-align:center; padding: 50px; color: #f44336;"><h1>‚ùå Session not found</h1></div>';
      });

    // --- Autocomplete Logic ---
    function setupAutocomplete() {
      const input = document.getElementById('compare-id-input');
      const resultsBox = document.getElementById('autocomplete-results');
      let selectedIndex = -1;

      input.addEventListener('input', () => {
        const query = input.value.trim().toLowerCase();
        const currentIds = input.value.split(',').map(id => id.trim());
        const lastQuery = currentIds[currentIds.length - 1].toLowerCase();

        resultsBox.innerHTML = '';
        selectedIndex = -1;

        if (lastQuery.length < 2) {
          resultsBox.style.display = 'none';
          return;
        }

        const filtered = allSessionsList
          .filter(session =>
            session.id.toLowerCase().includes(lastQuery) ||
            session.driver.toLowerCase().includes(lastQuery) ||
            session.track.name.toLowerCase().includes(lastQuery)
          )
          .slice(0, 5);

        if (filtered.length > 0) {
          resultsBox.style.display = 'block';
          filtered.forEach((session, index) => {
            const item = document.createElement('div');
            item.className = 'autocomplete-item';
            item.textContent = `${session.driver} @ ${session.track.name} (${session.session_date})`;
            item.dataset.id = session.id;

            item.addEventListener('click', () => {
              currentIds[currentIds.length - 1] = session.id;
              input.value = currentIds.join(', ') + ', ';
              resultsBox.style.display = 'none';
              input.focus();
            });
            resultsBox.appendChild(item);
          });
        } else {
          resultsBox.style.display = 'none';
        }
      });

      input.addEventListener('keydown', (e) => {
        const items = resultsBox.querySelectorAll('.autocomplete-item');
        if (items.length === 0) return;

        if (e.key === 'ArrowDown') {
          e.preventDefault();
          selectedIndex = (selectedIndex + 1) % items.length;
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          selectedIndex = (selectedIndex - 1 + items.length) % items.length;
        } else if (e.key === 'Enter' && selectedIndex >= 0) {
          e.preventDefault();
          items[selectedIndex].click();
        }

        items.forEach((item, index) => {
          item.classList.toggle('selected', index === selectedIndex);
          if (index === selectedIndex) {
            item.scrollIntoView({ block: 'nearest' });
          }
        });
      });

      document.addEventListener('click', (e) => {
        if (!resultsBox.contains(e.target) && e.target !== input) {
          resultsBox.style.display = 'none';
        }
      });
    }

    // --- Utility Functions ---
    function parseTime(timeStr) {
      if (!timeStr) return 0;
      const parts = timeStr.toString().split(':');
      if (parts.length === 2) {
        const minutes = parseInt(parts[0]) || 0;
        const seconds = parseFloat(parts[1]) || 0;
        return minutes * 60 + seconds;
      }
      return parseFloat(timeStr) || 0;
    }

    function formatTime(seconds) {
      if (seconds === null || seconds === undefined) return 'N/A';
      if (typeof seconds !== 'number' || isNaN(seconds)) return 'N/A';
      const totalSeconds = Math.max(0, seconds);
      const mins = Math.floor(totalSeconds / 60);
      const secs = (totalSeconds % 60).toFixed(3);
      const formattedSecs = secs.padStart(6, '0');
      return mins > 0 ? `${mins}:${formattedSecs}` : `${parseFloat(secs).toFixed(3)}s`;
    }

    function calculateConsistency(lapTimes) {
      if (lapTimes.length < 2) return 0;
      const avg = lapTimes.reduce((a, b) => a + b, 0) / lapTimes.length;
      const variance = lapTimes.reduce((sum, time) => sum + Math.pow(time - avg, 2), 0) / lapTimes.length;
      return Math.sqrt(variance);
    }

    function getConsistencyRating(stdDev) {
      if (stdDev < 0.3) return { text: 'Excellent', class: 'consistency-excellent' };
      if (stdDev < 0.6) return { text: 'Good', class: 'consistency-good' };
      if (stdDev < 1.0) return { text: 'Fair', class: 'consistency-fair' };
      return { text: 'Variable', class: 'consistency-poor' };
    }

    // --- Video Player Functions ---
    window.onYouTubeIframeAPIReady = function () {
      if (!pendingVideoConfig) return;
      const { videoId, startTimeSeconds } = pendingVideoConfig;
      if (!document.getElementById('youtube-player-container')) return;

      player = new YT.Player('youtube-player-container', {
        videoId: videoId,
        playerVars: {
          start: startTimeSeconds,
          autoplay: 0,
          rel: 0,
          modestbranding: 1,
          origin: window.location.origin,
          enablejsapi: 1
        },
        events: {
          'onReady': onPlayerReady,
          'onStateChange': onPlayerStateChange // Added State Change listener
        }
      });
    };

    function extractYouTubeId(url) {
      const regex = /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i;
      const match = url.match(regex);
      return match ? match[1] : null;
    }

    function renderVideoPlayer(videoUrl, videoStartTime) {
      const videoContainer = document.getElementById('video-display-container');
      videoContainer.style.display = 'none';
      videoContainer.innerHTML = '';

      if (!videoUrl || videoUrl.trim() === '') return;

      if (videoUrl.toLowerCase() === 'pending') {
        videoContainer.style.display = 'block';
        videoContainer.innerHTML = `
            <div class="chart-title">üé• Session Video</div>
            <p style="text-align: center; padding: 20px 0; font-size: 1.2em; color: #ffeb3b;">
                Video will be available soon! Please check back later.
            </p>
        `;
        return;
      }

      const videoId = extractYouTubeId(videoUrl);
      if (videoId) {
        videoContainer.style.display = 'block';
        videoContainer.innerHTML = `
            <div class="chart-title">üé• Session Video</div>
            <div class="video-responsive">
                <div id="youtube-player-container"></div>
            </div>
        `;

        pendingVideoConfig = {
          videoId: videoId,
          startTimeSeconds: parseTime(videoStartTime)
        };

        if (window.YT && window.YT.Player) {
          window.onYouTubeIframeAPIReady();
        }
      }
    }

    function onPlayerReady(event) {
      // Initial sync
      seekToLap(1);
    }

    function onPlayerStateChange(event) {
      if (event.data === YT.PlayerState.PLAYING) {
        startChartUpdateInterval();
      } else {
        if (updateChartInterval) clearInterval(updateChartInterval);
      }
    }

    // --- NEW: Universal Seek Function ---
    function seekToLap(lapNumber) {
      // Ensure lapNumber is within bounds
      const maxLap = parseInt(document.getElementById('lap-selector-slider').max);
      if (lapNumber < 1) lapNumber = 1;
      if (lapNumber > maxLap) lapNumber = maxLap;

      const lapStartTimeObj = lapStartTimes.find(l => l.lapNumber === lapNumber);

      if (lapStartTimeObj && player && typeof player.seekTo === 'function') {
        player.seekTo(lapStartTimeObj.videoTime, true);
      }

      // Update the marker instantly and display
      currentLapMarker.lapNumber = lapNumber;
      document.getElementById('lap-selector-slider').value = lapNumber;
      document.getElementById('current-lap-display').textContent = `Current Lap: ${lapNumber}`;

      // Redraw chart to move the marker
      if (currentSessionData) {
        const currentLaps = currentSessionData.laps.filter(l => l.lap !== null && parseTime(l.time) !== null);
        const existingComparisonDatasets = comparisonDatasets.length > 0 ? comparisonDatasets : [];
        drawLineChart(currentLaps, existingComparisonDatasets);
      }
    }

    // --- NEW: Helper to find current lap based on video time ---
    function getCurrentLapNumber(currentVideoTime) {
      // Reverse iterate to find the latest lap start time that is less than current video time
      // or iterate forward.
      for (let i = lapStartTimes.length - 1; i >= 0; i--) {
        if (currentVideoTime >= lapStartTimes[i].videoTime) {
          return lapStartTimes[i].lapNumber;
        }
      }
      return 1;
    }

    // --- NEW: Interval Logic ---
    function startChartUpdateInterval() {
      if (updateChartInterval) clearInterval(updateChartInterval);

      updateChartInterval = setInterval(() => {
        if (player && typeof player.getCurrentTime === 'function' && currentLapMarker.lapNumber !== -1) {
          const videoTime = player.getCurrentTime();
          const newLapNumber = getCurrentLapNumber(videoTime);

          if (newLapNumber !== currentLapMarker.lapNumber) {
            currentLapMarker.lapNumber = newLapNumber;

            // Sync Slider
            const slider = document.getElementById('lap-selector-slider');
            if (slider) slider.value = newLapNumber;

            // Sync Text
            document.getElementById('current-lap-display').textContent = `Current Lap: ${newLapNumber}`;

            // Redraw the chart to move the marker
            if (currentSessionData) {
              const currentLaps = currentSessionData.laps.filter(l => l.lap !== null && parseTime(l.time) !== null);
              const existingComparisonDatasets = comparisonDatasets.length > 0 ? comparisonDatasets : [];
              drawLineChart(currentLaps, existingComparisonDatasets);
            }
          }
        }
      }, 250); // Update 4 times per second
    }

    // --- Chart & Tooltip Interaction ---
    function setupTooltipInteractions() {
      const canvas = document.getElementById('lap-chart');
      if (canvas.currentMouseMoveHandler) canvas.removeEventListener('mousemove', canvas.currentMouseMoveHandler);
      if (canvas.currentMouseLeaveHandler) canvas.removeEventListener('mouseleave', canvas.currentMouseLeaveHandler);
      if (canvas.currentTouchMoveHandler) canvas.removeEventListener('touchmove', canvas.currentTouchMoveHandler);
      if (canvas.currentTouchEndHandler) canvas.removeEventListener('touchend', canvas.currentTouchEndHandler);

      canvas.currentMouseMoveHandler = (e) => { handleInteraction(e.clientX, e.clientY); };
      canvas.currentMouseLeaveHandler = () => { activePoint = null; hideTooltip(); };
      canvas.currentTouchMoveHandler = (e) => {
        if (e.touches.length > 0) {
          e.preventDefault();
          handleInteraction(e.touches[0].clientX, e.touches[0].clientY);
        }
      };
      canvas.currentTouchEndHandler = () => { setTimeout(() => { activePoint = null; hideTooltip(); }, 500); };

      canvas.addEventListener('mousemove', canvas.currentMouseMoveHandler);
      canvas.addEventListener('mouseleave', canvas.currentMouseLeaveHandler);
      canvas.addEventListener('touchmove', canvas.currentTouchMoveHandler, { passive: false });
      canvas.addEventListener('touchend', canvas.currentTouchEndHandler);

      function handleInteraction(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        let closestPoint = null;
        let minDistance = Infinity;

        chartPoints.forEach(point => {
          const hitRadius = 15;
          const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
          if (distance < hitRadius && distance < minDistance) {
            minDistance = distance;
            closestPoint = point;
          }
        });

        if (closestPoint) {
          const pointIdentifier = `${closestPoint.lapNumber}-${closestPoint.isComparison}-${closestPoint.sessionIndex}`;
          if (!activePoint || activePoint.identifier !== pointIdentifier) {
            activePoint = { ...closestPoint, identifier: pointIdentifier };
            showTooltip(activePoint, clientX, clientY);
          }
        } else {
          activePoint = null;
          hideTooltip();
        }
      }
    }

    function showTooltip(point, mouseX, mouseY) {
      const tooltip = document.getElementById('chart-tooltip');
      const canvas = document.getElementById('lap-chart');
      const canvasRect = canvas.getBoundingClientRect();

      let session = currentSessionData;
      let dataset = currentDataset;
      let fastestTime = Math.min(...dataset.map(l => parseTime(l.time)));
      let driverLabel = '';
      let lineColor = '#f44336';

      if (point.isComparison && point.sessionIndex !== undefined) {
        session = comparisonSessions[point.sessionIndex];
        dataset = comparisonDatasets[point.sessionIndex];
        fastestTime = Math.min(...dataset.map(l => parseTime(l.time)));
        lineColor = comparisonColors[point.sessionIndex % comparisonColors.length].line;
        driverLabel = `<span class="tooltip-driver" style="color: ${lineColor};">${session.driver}</span>`;
      } else if (point.isComparison === false) {
        driverLabel = `<span class="tooltip-driver" style="color: #ffd700;">${session.driver}</span>`;
      }

      const currentTime = parseTime(point.lap.time);
      const delta = currentTime - fastestTime;
      const deltaStr = delta === 0 ? 'Fastest Lap' : (delta > 0 ? `+${delta.toFixed(3)}s` : `${delta.toFixed(3)}s`);

      const tooltipHTML = `
                <div class="tooltip-header">
                    ${driverLabel}
                    <span class="tooltip-lap">Lap ${point.lapNumber}</span>
                </div>
                <div class="tooltip-time">${point.lap.time}</div>
                ${point.lap.best ? '<div class="tooltip-best">‚òÖ Best Lap</div>' : ''}
                <div class="tooltip-delta">Delta to Session Best: ${deltaStr}</div>
                <div class="tooltip-footer">
                    Session: ${new Date(session.session_date).toLocaleDateString()}<br>
                    Kart: ${session.kart}
                </div>
            `;

      tooltip.innerHTML = tooltipHTML + '<div class="tooltip-arrow"></div>';
      tooltip.classList.add('tooltip-visible');

      const tooltipWidth = tooltip.offsetWidth;
      const tooltipHeight = tooltip.offsetHeight;
      const scrollX = window.scrollX || window.pageXOffset;
      const scrollY = window.scrollY || window.pageYOffset;
      const pointDocumentX = canvasRect.left + scrollX + point.x;
      const pointDocumentY = canvasRect.top + scrollY + point.y;

      let left = pointDocumentX - tooltipWidth / 2;
      let top = pointDocumentY - tooltipHeight - 20;

      if (left < scrollX + 20) left = scrollX + 20;
      if (left + tooltipWidth > scrollX + window.innerWidth - 20) left = scrollX + window.innerWidth - tooltipWidth - 20;

      const arrow = tooltip.querySelector('.tooltip-arrow');
      if (top < scrollY + 20) {
        top = pointDocumentY + 30;
        arrow.style.borderTop = 'none';
        arrow.style.borderBottom = `8px solid ${lineColor}`;
        arrow.style.top = '-8px';
        arrow.style.bottom = 'auto';
        arrow.style.marginLeft = '0';
      } else {
        arrow.style.borderTop = `8px solid ${lineColor}`;
        arrow.style.borderBottom = 'none';
        arrow.style.bottom = '-8px';
        arrow.style.top = 'auto';
        arrow.style.marginLeft = '0';
      }

      const tooltipMidpointOnPage = left + tooltipWidth / 2;
      const arrowOffsetX = pointDocumentX - tooltipMidpointOnPage;
      arrow.style.marginLeft = `${arrowOffsetX}px`;

      tooltip.style.left = left + 'px';
      tooltip.style.top = top + 'px';
    }

    function hideTooltip() {
      const tooltip = document.getElementById('chart-tooltip');
      tooltip.classList.remove('tooltip-visible');
    }

    function drawLineChart(mainLaps, compareLapsArray = []) {
      const canvas = document.getElementById('lap-chart');
      const ctx = canvas.getContext('2d');

      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      const padding = 60;
      const chartWidth = canvas.width - padding * 2;
      const chartHeight = canvas.height - padding * 2;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      chartPoints = [];
      currentDataset = mainLaps;
      comparisonDatasets = compareLapsArray;

      const allDatasets = [mainLaps, ...compareLapsArray];
      const allLaps = allDatasets.flat();
      const lapTimes = allLaps.map(lap => parseTime(lap.time)).filter(time => !isNaN(time));

      if (lapTimes.length === 0) {
        ctx.fillStyle = '#999';
        ctx.textAlign = 'center';
        ctx.fillText("No lap data available to chart.", canvas.width / 2, canvas.height / 2);
        return;
      }

      const minTime = Math.min(...lapTimes);
      const maxTime = Math.max(...lapTimes);
      const timeRange = maxTime - minTime || 1;
      const maxLapsCount = allDatasets.reduce((max, dataset) => Math.max(max, dataset.length), 0);
      const overallFastestTime = minTime;

      function getCoords(i, lapTime) {
        const x = padding + (chartWidth / (maxLapsCount - 1 || 1)) * i;
        const y = padding + chartHeight - ((lapTime - minTime) / timeRange) * chartHeight;
        return { x, y };
      }

      // Grid Lines
      ctx.strokeStyle = '#3d3d3d';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = padding + (chartHeight / 5) * i;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(canvas.width - padding, y);
        ctx.stroke();
      }
      for (let i = 0; i < maxLapsCount; i++) {
        const x = padding + (chartWidth / (maxLapsCount - 1 || 1)) * i;
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, canvas.height - padding);
        ctx.strokeStyle = '#2d2d2d';
        ctx.stroke();
      }

      if (overallFastestTime) {
        const { y: baselineY } = getCoords(0, overallFastestTime);
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(padding, baselineY);
        ctx.lineTo(canvas.width - padding, baselineY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#ffd700';
        ctx.textAlign = 'left';
        ctx.fillText(`Overall Best: ${formatTime(overallFastestTime)}`, padding + 5, baselineY - 5);
      }

      // --- NEW: Highlight Current Lap Marker ---
      // Draw this BEHIND the points but in front of the grid
      if (currentLapMarker.lapNumber > 0 && currentLapMarker.lapNumber <= mainLaps.length) {
        const currentIndex = currentLapMarker.lapNumber - 1;
        const xPos = padding + (chartWidth / (maxLapsCount - 1 || 1)) * currentIndex;

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; // Faint white line
        ctx.lineWidth = 40; // Wide highlight
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(xPos, padding);
        ctx.lineTo(xPos, canvas.height - padding);
        ctx.stroke();

        // Sharper center line
        ctx.strokeStyle = '#f44336';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(xPos, padding);
        ctx.lineTo(xPos, canvas.height - padding);
        ctx.stroke();
      }

      function drawLapLine(laps, color, pointColor, isComparison = false, sessionIndex = -1) {
        if (laps.length === 0) return;
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        laps.forEach((lap, i) => {
          const lapTime = parseTime(lap.time);
          if (isNaN(lapTime)) return;
          const { x, y } = getCoords(i, lapTime);
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          chartPoints.push({ x, y, lap, lapNumber: lap.lap, isComparison, sessionIndex });
        });
        ctx.stroke();

        laps.forEach((lap, i) => {
          const lapTime = parseTime(lap.time);
          if (isNaN(lapTime)) return;
          const { x, y } = getCoords(i, lapTime);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.0)';
          ctx.beginPath();
          ctx.arc(x, y, 15, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = pointColor;
          ctx.beginPath();
          ctx.arc(x, y, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 1;
          ctx.stroke();
        });
      }

      function drawBestLapMarkers(laps) {
        const bestLapIndex = laps.findIndex(lap => lap.best);
        if (bestLapIndex !== -1) {
          const lapTime = parseTime(laps[bestLapIndex].time);
          if (isNaN(lapTime)) return;
          const { x, y } = getCoords(bestLapIndex, lapTime);
          ctx.fillStyle = '#ffd700';
          ctx.beginPath();
          ctx.moveTo(x, y - 10);
          for (let i = 1; i <= 5; i++) {
            const angle = (i * 4 * Math.PI) / 5;
            const radius = i % 2 === 0 ? 8 : 4;
            ctx.lineTo(x + Math.sin(angle) * radius, y - Math.cos(angle) * radius);
          }
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }

      compareLapsArray.forEach((laps, index) => {
        const colors = comparisonColors[index % comparisonColors.length];
        drawLapLine(laps, colors.line, colors.point, true, index);
      });

      drawLapLine(mainLaps, '#f44336', '#ff5252', false, -1);
      allDatasets.forEach(laps => drawBestLapMarkers(laps));

      ctx.fillStyle = '#999';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      for (let i = 0; i < maxLapsCount; i++) {
        const x = padding + (chartWidth / (maxLapsCount - 1 || 1)) * i;
        if (i % Math.ceil(maxLapsCount / 10) === 0 || i === maxLapsCount - 1) {
          ctx.fillText(`L${i + 1}`, x, canvas.height - 20);
        }
      }

      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (let i = 0; i <= 5; i++) {
        const y = padding + (chartHeight / 5) * i;
        const time = maxTime - (timeRange / 5) * i;
        ctx.fillText(formatTime(time), padding - 10, y);
      }

      const legend = document.getElementById('chart-legend');
      let legendHTML = `
                <div class="legend-item">
                    <div class="legend-color" style="background: #f44336;"></div>
                    <span>${currentSessionData.driver} (${mainLaps.length} laps)</span>
                </div>
            `;
      comparisonSessions.forEach((session, index) => {
        const colors = comparisonColors[index % comparisonColors.length];
        legendHTML += `
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${colors.line};"></div>
                        <span>${session.driver} (${comparisonDatasets[index].length} laps)</span>
                    </div>
                `;
      });
      legendHTML += `
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd700;"></div>
                    <span>‚òÖ Best Lap / Overall Best Baseline</span>
                </div>
            `;
      legend.innerHTML = legendHTML;

      setupTooltipInteractions();
    }

    function renderSession(data) {
      document.getElementById('driver').textContent = data.driver;
      const validLaps = data.laps.filter(lap => lap.lap !== null && parseTime(lap.time) !== null);
      const lapTimes = validLaps.map(lap => parseTime(lap.time)).filter(time => !isNaN(time));
      const fastestTime = lapTimes.length > 0 ? Math.min(...lapTimes) : 0;
      const fastestLapIndex = lapTimes.indexOf(fastestTime);

      validLaps.forEach((lap, i) => { lap.best = (i === fastestLapIndex); });

      document.getElementById('fastest').textContent = formatTime(fastestTime);
      document.getElementById('track-link').textContent = data.track.name;
      document.getElementById('track-link').href = data.track.maps_link;
      document.getElementById('kart').textContent = data.kart;
      document.getElementById('session-date').textContent = new Date(data.session_date).toLocaleDateString('en-US', {
        year: 'numeric', month: 'long', day: 'numeric'
      });
      document.getElementById('total-laps').textContent = validLaps.length;
      const avgTime = lapTimes.length > 0 ? lapTimes.reduce((a, b) => a + b, 0) / lapTimes.length : 0;
      document.getElementById('average').textContent = formatTime(avgTime);
      const stdDev = calculateConsistency(lapTimes);
      const consistency = getConsistencyRating(stdDev);
      const consistencyEl = document.getElementById('consistency');
      consistencyEl.textContent = `${consistency.text} (¬±${stdDev.toFixed(3)}s)`;
      consistencyEl.className = `stat-value small ${consistency.class}`;

      renderVideoPlayer(data.video_url, data.video_start_time);

      // --- NEW: Calculate Lap Video Timestamps & Setup Slider ---
      const slider = document.getElementById('lap-selector-slider');
      slider.max = validLaps.length;
      slider.value = 1;
      slider.oninput = function () { seekToLap(parseInt(this.value)); };

      const videoStartTime = parseTime(data.video_start_time || "0:00");
      let cumulativeTime = videoStartTime;
      lapStartTimes = []; // Reset global

      // Lap 1
      lapStartTimes.push({ lapNumber: 1, videoTime: cumulativeTime });

      // Calculate subsequent laps
      for (let i = 0; i < validLaps.length - 1; i++) {
        cumulativeTime += parseTime(validLaps[i].time);
        lapStartTimes.push({ lapNumber: i + 2, videoTime: cumulativeTime });
      }
      // --- END NEW ---

      drawLineChart(validLaps);
    }

    async function compareSession() {
      const compareIdsInput = document.getElementById('compare-id-input').value.trim();
      let sessionIds = compareIdsInput.split(',').map(id => id.trim()).filter(id => id.length > 0 && id !== sessionId);
      sessionIds = Array.from(new Set(sessionIds));
      comparisonSessions = [];
      comparisonDatasets = [];

      if (!currentSessionData) return;
      const currentLaps = currentSessionData.laps.filter(l => l.lap !== null && parseTime(l.time) !== null);

      if (sessionIds.length === 0) {
        drawLineChart(currentLaps, []);
        document.getElementById('comparison-results').innerHTML = '';
        const currentTimes = currentLaps.map(l => parseTime(l.time));
        const currentFastest = currentTimes.length > 0 ? Math.min(...currentTimes) : 0;
        const currentAvg = currentTimes.length > 0 ? currentTimes.reduce((sum, t) => sum + t, 0) / currentTimes.length : 0;
        document.getElementById('comparison-results').innerHTML = createComparisonCard(currentSessionData, currentFastest, currentAvg, currentLaps.length, '#f44336');
        return;
      }

      const fetchPromises = sessionIds.map(id =>
        fetch(`sessions/${id}.json`)
          .then(r => r.ok ? r.json() : Promise.reject(`Session ${id} not found`))
          .catch(err => ({ error: err }))
      );

      const results = await Promise.all(fetchPromises);
      const successfulSessions = results.filter(r => !r.error);
      const errorSessions = results.filter(r => r.error);

      successfulSessions.forEach(sessionData => {
        const compareLaps = sessionData.laps.filter(l => l.lap !== null && parseTime(l.time) !== null);
        const compareTimes = compareLaps.map(l => parseTime(l.time));
        const compareFastest = compareTimes.length > 0 ? Math.min(...compareTimes) : 0;
        const compareFastestIdx = compareTimes.indexOf(compareFastest);
        compareLaps.forEach((lap, i) => lap.best = (i === compareFastestIdx));
        comparisonSessions.push(sessionData);
        comparisonDatasets.push(compareLaps);
      });

      const currentTimes = currentLaps.map(l => parseTime(l.time));
      const currentFastest = currentTimes.length > 0 ? Math.min(...currentTimes) : 0;
      const currentFastestIdx = currentTimes.indexOf(currentFastest);
      currentLaps.forEach((lap, i) => lap.best = (i === currentFastestIdx));

      drawLineChart(currentLaps, comparisonDatasets);

      let resultHTML = '';
      const currentAvg = currentTimes.length > 0 ? currentTimes.reduce((sum, t) => sum + t, 0) / currentTimes.length : 0;
      resultHTML += createComparisonCard(currentSessionData, currentFastest, currentAvg, currentLaps.length, '#f44336');

      comparisonSessions.forEach((session, index) => {
        const laps = comparisonDatasets[index];
        const times = laps.map(l => parseTime(l.time));
        const fastest = times.length > 0 ? Math.min(...times) : 0;
        const avg = times.length > 0 ? times.reduce((sum, t) => sum + t, 0) / times.length : 0;
        const color = comparisonColors[index % comparisonColors.length].line;
        resultHTML += createComparisonCard(session, fastest, avg, laps.length, color);
      });

      if (comparisonSessions.length > 0) {
        const allFastestTimes = [
          { time: currentFastest, driver: currentSessionData.driver, color: '#f44336' },
          ...comparisonSessions.map((s, i) => ({
            time: Math.min(...comparisonDatasets[i].map(l => parseTime(l.time))),
            driver: s.driver,
            color: comparisonColors[i % comparisonColors.length].line
          }))
        ];
        const overallBest = allFastestTimes.reduce((best, current) => current.time < best.time ? current : best, allFastestTimes[0]);
        resultHTML += `
                    <div class="comparison-card">
                        <h3>üèÜ Overall Fastest Lap</h3>
                        <p><strong>Time:</strong> <strong class="fastest-time" style="font-size: 1.8em; color: ${overallBest.color};">${formatTime(overallBest.time)}</strong></p>
                        <p><strong>Driver:</strong> <strong style="color: ${overallBest.color};">${overallBest.driver}</strong></p>
                        <p><strong>Session:</strong> ${overallBest.driver === currentSessionData.driver ? new Date(currentSessionData.session_date).toLocaleDateString() : new Date(comparisonSessions.find(s => s.driver === overallBest.driver)?.session_date || 'Unknown').toLocaleDateString()}</p>
                    </div>
                `;
      }
      errorSessions.forEach(err => { resultHTML += `<div class="error-message">${err.error}</div>`; });
      document.getElementById('comparison-results').innerHTML = resultHTML;
    }

    function createComparisonCard(data, fastest, average, lapCount, color) {
      const stdDev = calculateConsistency(data.laps.filter(l => l.lap !== null).map(l => parseTime(l.time)));
      const consistency = getConsistencyRating(stdDev);
      const sessionDate = new Date(data.session_date).toLocaleDateString();
      return `
                <div class="comparison-card" style="border-top-color: ${color};">
                    <h3>${data.driver} - ${sessionDate}</h3>
                    <p><strong>Session ID:</strong> <code>${data.id}</code></p>
                    <p><strong>Track:</strong> ${data.track.name}</p>
                    <p><strong>Fastest:</strong> <span style="font-weight: bold; color: ${color === '#f44336' ? '#ffd700' : color};">${formatTime(fastest)}</span></p>
                    <p><strong>Average:</strong> ${formatTime(average)}</p>
                    <p><strong>Laps:</strong> ${lapCount}</p>
                    <p><strong>Consistency:</strong> <span class="${consistency.class}">${consistency.text} (¬±${stdDev.toFixed(3)}s)</span></p>
                    <p><strong>Kart:</strong> ${data.kart}</p>
                </div>
            `;
    }

    function clearComparison() {
      comparisonSessions = [];
      comparisonDatasets = [];
      document.getElementById('compare-id-input').value = '';
      if (currentSessionData) {
        const validLaps = currentSessionData.laps.filter(lap => lap.lap !== null && parseTime(lap.time) !== null);
        drawLineChart(validLaps, []);
        compareSession();
      }
    }
  </script>
</body>

</html>